// Generated by CoffeeScript 1.7.1
var File, Folder, async, combinedStreamPath, downloader, feed, folderParent, fs, getFileClass, log, mime, moment, monkeypatch, multiparty, normalizePath, pathHelpers, processAttachement, resetTimeout, sharing, timeout, updateParents,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

fs = require('fs');

async = require('async');

moment = require('moment');

multiparty = require('multiparty');

mime = require('mime');

feed = require('../lib/feed');

downloader = require('../lib/downloader');

File = require('../models/file');

Folder = require('../models/folder');

sharing = require('../helpers/sharing');

pathHelpers = require('../helpers/path');

log = require('printit')({
  prefix: 'files'
});

normalizePath = function(path) {
  if (path[0] !== '/') {
    path = "/" + path;
  }
  if (path === "/") {
    path = "";
  }
  return path;
};

monkeypatch = function(ctx, fn, after) {
  var old;
  old = ctx[fn];
  return ctx[fn] = function() {
    return after.apply(this, arguments);
  };
};

combinedStreamPath = 'americano-cozy/' + 'node_modules/jugglingdb-cozy-adapter/' + 'node_modules/request-json/' + 'node_modules/request/' + 'node_modules/form-data/' + 'node_modules/combined-stream';

monkeypatch(require(combinedStreamPath).prototype, 'pause', function() {
  if (!this.pauseStreams) {
    return;
  }
  if (this.pauseStreams && typeof this._currentStream.pause === 'function') {
    this._currentStream.pause();
  }
  return this.emit('pause');
});

monkeypatch(require(combinedStreamPath).prototype, 'resume', function() {
  if (!this._released) {
    this._released = true;
    this.writable = true;
    this._getNext();
  }
  if (this.pauseStreams && typeof this._currentStream.resume === 'function') {
    this._currentStream.resume();
  }
  return this.emit('resume');
});

processAttachement = function(req, res, next, download) {
  var contentHeader, file;
  file = req.file;
  if (download) {
    contentHeader = "attachment; filename=" + file.name;
  } else {
    contentHeader = "inline; filename=" + file.name;
    res.setHeader('Content-type', file.mime);
  }
  res.setHeader('Content-Disposition', contentHeader);
  res.setHeader('Content-Length', file.size);
  return downloader.download("/data/" + file.id + "/binaries/file", function(stream) {
    if (stream.statusCode === 200) {
      stream.pipefilter = function(source, dest) {
        var XSSmimeTypes, _ref;
        XSSmimeTypes = ['text/html', 'image/svg+xml'];
        if (_ref = source.headers['content-type'], __indexOf.call(XSSmimeTypes, _ref) >= 0) {
          return dest.setHeader('content-type', 'text/plain');
        }
      };
      return stream.pipe(res);
    } else if (stream.statusCode === 404) {
      return next(new Error('An error occured while downloading the file: file not found.'));
    } else {
      return next(new Error('An error occured while downloading the file.'));
    }
  });
};

getFileClass = function(file) {
  var fileClass, type;
  type = file.headers['content-type'];
  switch (type.split('/')[0]) {
    case 'image':
      fileClass = "image";
      break;
    case 'application':
      fileClass = "document";
      break;
    case 'text':
      fileClass = "document";
      break;
    case 'audio':
      fileClass = "music";
      break;
    case 'video':
      fileClass = "video";
      break;
    default:
      fileClass = "file";
  }
  return fileClass;
};

module.exports.fetch = function(req, res, next, id) {
  return File.request('all', {
    key: id
  }, function(err, file) {
    if (err || !file || file.length === 0) {
      if (err == null) {
        err = new Error('File not found');
        err.status = 404;
        err.template = {
          name: '404',
          params: {
            localization: require('../lib/localization_manager'),
            isPublic: req.url.indexOf('public') !== -1
          }
        };
      }
      return next(err);
    } else {
      req.file = file[0];
      return next();
    }
  });
};

module.exports.find = function(req, res) {
  return res.send(req.file);
};

module.exports.all = function(req, res, next) {
  return File.all(function(err, files) {
    if (err) {
      return next(err);
    } else {
      return res.send(files);
    }
  });
};

folderParent = {};

timeout = null;

module.exports.create = function(req, res, next) {
  var fields, form;
  if (timeout != null) {
    clearTimeout(timeout);
  }
  fields = {};
  form = new multiparty.Form();
  form.on('part', function(part) {
    var err, fullPath, name, path;
    if (part.filename == null) {
      fields[part.name] = '';
      return part.on('data', function(buffer) {
        return fields[part.name] = buffer.toString();
      });
    } else {
      name = fields.name;
      path = fields.path;
      if (!name || name === "") {
        err = new Error("Invalid arguments: no name given");
        err.status = 400;
        return next(err);
      } else {
        path = normalizePath(path);
        fullPath = "" + path + "/" + name;
        return File.byFullPath({
          key: fullPath
        }, (function(_this) {
          return function(err, sameFiles) {
            var createFile, data, fileClass, now, upload;
            if (err) {
              return next(err);
            }
            if (sameFiles.length > 0) {
              return res.send({
                error: true,
                code: 'EEXISTS',
                msg: "This file already exists"
              }, 400);
            } else {
              now = moment().toISOString();
              fileClass = getFileClass(part);
              data = {
                name: name,
                path: path,
                creationDate: now,
                lastModification: now,
                mime: mime.lookup(name),
                size: part.byteCount,
                tags: [],
                "class": fileClass
              };
              upload = true;
              createFile = function() {
                var attachBinary, index, keepAlive;
                attachBinary = function(newFile) {
                  part.path = data.name;
                  return newFile.attachBinary(part, {
                    "name": "file"
                  }, function(err, res, body) {
                    upload = false;
                    if (err) {
                      return newFile.destroy(function(error) {
                        var stringErr;
                        stringErr = err.toString();
                        if (stringErr.indexOf('enough storage') !== -1) {
                          return res.send({
                            error: true,
                            code: 'ESTORAGE',
                            msg: "modal error size"
                          }, 400);
                        } else {
                          return next(err);
                        }
                      });
                    } else {
                      return index(newFile);
                    }
                  });
                };
                index = function(newFile) {
                  return newFile.index(["name"], function(err) {
                    var who;
                    if (err) {
                      log.debug(err);
                    }
                    who = req.guestEmail || 'owner';
                    return sharing.notifyChanges(who, newFile, function(err) {
                      if (err) {
                        log.debug(err);
                      }
                      return res.send(newFile, 200);
                    });
                  });
                };
                keepAlive = function() {
                  if (upload) {
                    feed.publish('usage.application', 'files');
                    return setTimeout(function() {
                      return keepAlive();
                    }, 60 * 1000);
                  }
                };
                return File.create(data, function(err, newFile) {
                  if (err) {
                    return next(err);
                  } else {
                    attachBinary(newFile);
                    return keepAlive();
                  }
                });
              };
              return Folder.byFullPath({
                key: data.path
              }, function(err, parents) {
                var parent;
                if (err) {
                  return next(err);
                }
                if (parents.length > 0) {
                  parent = parents[0];
                  data.tags = parent.tags;
                  parent.lastModification = now;
                  folderParent[parent.name] = parent;
                  return createFile();
                } else {
                  return createFile();
                }
              });
            }
          };
        })(this));
      }
    }
  });
  form.on('error', function(err) {
    return log.error(err);
  });
  return form.parse(req);
};

resetTimeout = (function(_this) {
  return function() {
    if (timeout != null) {
      clearTimeout(timeout);
    }
    return timeout = setTimeout(function() {
      return updateParents();
    }, 60 * 1000);
  };
})(this);

updateParents = function() {
  var errors, folder, name, _i, _len, _ref;
  errors = {};
  _ref = Object.keys(folderParent);
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    name = _ref[_i];
    folder = folderParent[name];
    folder.save(function(err) {
      if (err != null) {
        return errors[folder.name] = err;
      }
    });
  }
  return folderParent = {};
};

module.exports.modify = function(req, res, next) {
  var body, file, isPublic, newFullPath, newName, newPath, previousFullPath, previousName, previousPath, tags, _ref, _ref1;
  log.info("File modification of " + req.file.name + "...");
  file = req.file;
  body = req.body;
  if (body.tags && (Array.isArray(body.tags)) && ((_ref = file.tags) != null ? _ref.toString() : void 0) !== ((_ref1 = body.tags) != null ? _ref1.toString() : void 0)) {
    tags = body.tags;
    tags = tags.filter(function(tag) {
      return typeof tag === 'string';
    });
    return file.updateAttributes({
      tags: tags
    }, (function(_this) {
      return function(err) {
        if (err) {
          return next(new Error("Cannot change tags: " + err));
        } else {
          log.info("Tags changed for " + file.name + ": " + tags);
          return res.send({
            success: 'Tags successfully changed'
          }, 200);
        }
      };
    })(this));
  } else if ((!body.name || body.name === "") && (body.path == null)) {
    log.info("No arguments, no modification performed for " + req.file.name);
    return next(new Error("Invalid arguments, name should be specified."));
  } else {
    previousName = file.name;
    newName = body.name != null ? body.name : previousName;
    previousPath = file.path;
    if (req.body.path != null) {
      body.path = normalizePath(body.path);
    }
    newPath = body.path != null ? body.path : previousPath;
    isPublic = body["public"];
    newFullPath = "" + newPath + "/" + newName;
    previousFullPath = "" + previousPath + "/" + previousName;
    return File.byFullPath({
      key: newFullPath
    }, function(err, sameFiles) {
      var data, modificationSuccess;
      if (err) {
        return next(err);
      }
      modificationSuccess = function(err) {
        if (err) {
          log.raw(err);
        }
        log.info(("Filechanged from " + previousFullPath + " ") + ("to " + newFullPath));
        return res.send({
          success: 'File successfully modified'
        });
      };
      if (sameFiles.length > 0) {
        log.info("No modification: Name " + newName + " already exists.");
        return res.send(400, {
          error: true,
          msg: "The name is already in use."
        });
      } else {
        data = {
          name: newName,
          path: newPath,
          "public": isPublic,
          lastModification: moment().toISOString()
        };
        if (body.clearance) {
          data.clearance = body.clearance;
        }
        return file.updateAttributes(data, (function(_this) {
          return function(err) {
            if (err) {
              return next(new Error('Cannot modify file'));
            } else {
              return file.updateParentModifDate(function(err) {
                if (err) {
                  log.raw(err);
                }
                return file.index(["name"], modificationSuccess);
              });
            }
          };
        })(this));
      }
    });
  }
};

module.exports.destroy = function(req, res, next) {
  var file;
  file = req.file;
  return file.destroy((function(_this) {
    return function(err) {
      if (err) {
        log.error("Cannot destroy document " + file.id);
        return next(err);
      } else {
        return file.updateParentModifDate(function(err) {
          if (err) {
            log.raw(err);
          }
          return res.send({
            success: 'File successfully deleted'
          });
        });
      }
    };
  })(this));
};

module.exports.getAttachment = function(req, res, next) {
  return processAttachement(req, res, next, false);
};

module.exports.downloadAttachment = function(req, res, next) {
  return processAttachement(req, res, next, true);
};

module.exports.search = function(req, res, next) {
  var parts, query, sendResults, tag;
  sendResults = function(err, files) {
    if (err) {
      return next(err);
    } else {
      return res.send(files);
    }
  };
  query = req.body.id;
  query = query.trim();
  if (query.indexOf('tag:') !== -1) {
    parts = query.split();
    parts = parts.filter(function(tag) {
      return tag.indexOf('tag:' !== -1);
    });
    tag = parts[0].split('tag:')[1];
    return File.request('byTag', {
      key: tag
    }, sendResults);
  } else {
    return File.search("*" + query + "*", sendResults);
  }
};
