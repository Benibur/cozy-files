// Generated by CoffeeScript 1.8.0
var File, Folder, async, combinedStreamPath, confirmCanUpload, feed, folderParent, fs, getFileClass, isStorageError, log, mime, moment, monkeypatch, multiparty, normalizePath, pathHelpers, processAttachment, resetTimeout, sharing, timeout, updateParents, _ref;

fs = require('fs');

async = require('async');

moment = require('moment');

multiparty = require('multiparty');

mime = require('mime');

log = require('printit')({
  prefix: 'files'
});

File = require('../models/file');

Folder = require('../models/folder');

feed = require('../lib/feed');

sharing = require('../helpers/sharing');

pathHelpers = require('../helpers/path');

_ref = require('../helpers/file'), normalizePath = _ref.normalizePath, processAttachment = _ref.processAttachment, getFileClass = _ref.getFileClass;

monkeypatch = function(ctx, fn, after) {
  var old;
  old = ctx[fn];
  return ctx[fn] = function() {
    return after.apply(this, arguments);
  };
};

combinedStreamPath = 'americano-cozy/' + 'node_modules/jugglingdb-cozy-adapter/' + 'node_modules/request-json/' + 'node_modules/request/' + 'node_modules/form-data/' + 'node_modules/combined-stream';

monkeypatch(require(combinedStreamPath).prototype, 'pause', function() {
  if (!this.pauseStreams) {
    return;
  }
  if (this.pauseStreams && typeof this._currentStream.pause === 'function') {
    this._currentStream.pause();
  }
  return this.emit('pause');
});

monkeypatch(require(combinedStreamPath).prototype, 'resume', function() {
  if (!this._released) {
    this._released = true;
    this.writable = true;
    this._getNext();
  }
  if (this.pauseStreams && typeof this._currentStream.resume === 'function') {
    this._currentStream.resume();
  }
  return this.emit('resume');
});

module.exports.fetch = function(req, res, next, id) {
  return File.request('all', {
    key: id
  }, function(err, file) {
    if (err || !file || file.length === 0) {
      if (err == null) {
        err = new Error('File not found');
        err.status = 404;
        err.template = {
          name: '404',
          params: {
            localization: require('../lib/localization_manager'),
            isPublic: req.url.indexOf('public') !== -1
          }
        };
      }
      return next(err);
    } else {
      req.file = file[0];
      return next();
    }
  });
};

module.exports.find = function(req, res) {
  return res.send(req.file);
};

module.exports.all = function(req, res, next) {
  return File.all(function(err, files) {
    if (err) {
      return next(err);
    } else {
      return res.send(files);
    }
  });
};

folderParent = {};

timeout = null;

isStorageError = function(err) {
  return err.toString().indexOf('enough storage') !== -1;
};

resetTimeout = function() {
  if (timeout != null) {
    clearTimeout(timeout);
  }
  return timeout = setTimeout(updateParents, 60 * 1000);
};

updateParents = function() {
  var errors, folder, name, _i, _len, _ref1;
  errors = {};
  _ref1 = Object.keys(folderParent);
  for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
    name = _ref1[_i];
    folder = folderParent[name];
    folder.save(function(err) {
      if (err != null) {
        return errors[folder.name] = err;
      }
    });
  }
  return folderParent = {};
};

confirmCanUpload = function(data, req, next) {
  var element;
  if (!req["public"]) {
    return next(null);
  }
  element = new File(data);
  return sharing.checkClearance(element, req, 'w', function(authorized, rule) {
    var err;
    if (authorized) {
      if (rule != null) {
        req.guestEmail = rule.email;
        req.guestId = rule.contactid;
      }
      return next();
    } else {
      err = new Error('You cannot access this resource');
      err.status = 401;
      return next(err);
    }
  });
};

module.exports.create = function(req, res, next) {
  var fields, form;
  if (timeout != null) {
    clearTimeout(timeout);
  }
  fields = {};
  form = new multiparty.Form();
  form.on('part', function(part) {
    var attachBinary, err, fullPath, keepAlive, name, overwrite, path, rollback, upload;
    if (part.filename == null) {
      fields[part.name] = '';
      part.on('data', function(buffer) {
        return fields[part.name] = buffer.toString();
      });
      return;
    }
    name = fields.name;
    path = fields.path;
    overwrite = fields.overwrite;
    if (!name || name === "") {
      err = new Error("Invalid arguments: no name given");
      err.status = 400;
      return next(err);
    }
    upload = true;
    keepAlive = function() {
      if (upload) {
        feed.publish('usage.application', 'files');
        setTimeout(keepAlive, 60 * 1000);
        return resetTimeout();
      }
    };
    rollback = function(file, err) {
      return file.destroy(function(delerr) {
        if (delerr) {
          log.error(delerr);
        }
        if (isStorageError(err)) {
          return res.send({
            error: true,
            code: 'ESTORAGE',
            msg: "modal error size"
          }, 400);
        } else {
          return next(err);
        }
      });
    };
    attachBinary = function(file) {
      var metadata;
      part.path = file.name;
      metadata = {
        name: "file"
      };
      return file.attachBinary(part, metadata, function(err) {
        upload = false;
        if (err) {
          return rollback(file, err);
        }
        return file.index(["name"], function(err) {
          var who;
          if (err) {
            log.debug(err);
          }
          who = req.guestEmail || 'owner';
          return sharing.notifyChanges(who, file, function(err) {
            if (err) {
              log.debug(err);
            }
            return res.send(file, 200);
          });
        });
      });
    };
    path = normalizePath(path);
    fullPath = "" + path + "/" + name;
    return File.byFullPath({
      key: fullPath
    }, (function(_this) {
      return function(err, sameFiles) {
        var data, file, now;
        if (err) {
          return next(err);
        }
        if (sameFiles.length > 0) {
          if (overwrite) {
            file = sameFiles[0];
            keepAlive();
            return attachBinary(file);
          } else {
            upload = false;
            return res.send({
              error: true,
              code: 'EEXISTS',
              msg: "This file already exists"
            }, 400);
          }
        }
        now = moment().toISOString();
        data = {
          name: name,
          path: normalizePath(path),
          creationDate: now,
          lastModification: now,
          mime: mime.lookup(name),
          size: part.byteCount,
          tags: [],
          "class": getFileClass(part)
        };
        return confirmCanUpload(data, req, function(err) {
          if (err) {
            return next(err);
          }
          return Folder.byFullPath({
            key: data.path
          }, (function(_this) {
            return function(err, parents) {
              var parent;
              if (err) {
                return next(err);
              }
              if (parents.length > 0) {
                parent = parents[0];
                data.tags = parent.tags;
                parent.lastModification = now;
                folderParent[parent.name] = parent;
              }
              return File.create(data, function(err, newFile) {
                if (err) {
                  return next(err);
                }
                keepAlive();
                return attachBinary(newFile);
              });
            };
          })(this));
        });
      };
    })(this));
  });
  form.on('error', function(err) {
    return log.error(err);
  });
  return form.parse(req);
};

module.exports.publicCreate = function(req, res, next) {
  req["public"] = true;
  return module.exports.create(req, res, next);
};

module.exports.modify = function(req, res, next) {
  var body, file, isPublic, newFullPath, newName, newPath, previousFullPath, previousName, previousPath, tags, _ref1, _ref2;
  log.info("File modification of " + req.file.name + "...");
  file = req.file;
  body = req.body;
  if (body.tags && (Array.isArray(body.tags)) && ((_ref1 = file.tags) != null ? _ref1.toString() : void 0) !== ((_ref2 = body.tags) != null ? _ref2.toString() : void 0)) {
    tags = body.tags;
    tags = tags.filter(function(tag) {
      return typeof tag === 'string';
    });
    return file.updateAttributes({
      tags: tags
    }, (function(_this) {
      return function(err) {
        if (err) {
          return next(new Error("Cannot change tags: " + err));
        } else {
          log.info("Tags changed for " + file.name + ": " + tags);
          return res.send({
            success: 'Tags successfully changed'
          }, 200);
        }
      };
    })(this));
  } else if ((!body.name || body.name === "") && (body.path == null)) {
    log.info("No arguments, no modification performed for " + req.file.name);
    return next(new Error("Invalid arguments, name should be specified."));
  } else {
    previousName = file.name;
    newName = body.name != null ? body.name : previousName;
    previousPath = file.path;
    if (req.body.path != null) {
      body.path = normalizePath(body.path);
    }
    newPath = body.path != null ? body.path : previousPath;
    isPublic = body["public"];
    newFullPath = "" + newPath + "/" + newName;
    previousFullPath = "" + previousPath + "/" + previousName;
    return File.byFullPath({
      key: newFullPath
    }, function(err, sameFiles) {
      var data, modificationSuccess;
      if (err) {
        return next(err);
      }
      modificationSuccess = function(err) {
        if (err) {
          log.raw(err);
        }
        log.info(("Filechanged from " + previousFullPath + " ") + ("to " + newFullPath));
        return res.send({
          success: 'File successfully modified'
        });
      };
      if (sameFiles.length > 0) {
        log.info("No modification: Name " + newName + " already exists.");
        return res.send(400, {
          error: true,
          msg: "The name is already in use."
        });
      } else {
        data = {
          name: newName,
          path: normalizePath(newPath),
          "public": isPublic,
          lastModification: moment().toISOString()
        };
        if (body.clearance) {
          data.clearance = body.clearance;
        }
        return file.updateAttributes(data, (function(_this) {
          return function(err) {
            if (err) {
              return next(new Error('Cannot modify file'));
            } else {
              return file.updateParentModifDate(function(err) {
                if (err) {
                  log.raw(err);
                }
                return file.index(["name"], modificationSuccess);
              });
            }
          };
        })(this));
      }
    });
  }
};

module.exports.destroy = function(req, res, next) {
  var file;
  file = req.file;
  return file.destroyWithBinary(function(err) {
    if (err) {
      log.error("Cannot destroy document " + file.id);
      return next(err);
    } else {
      return file.updateParentModifDate(function(err) {
        if (err) {
          log.raw(err);
        }
        return res.send({
          success: 'File successfully deleted'
        });
      });
    }
  });
};

module.exports.getAttachment = function(req, res, next) {
  return processAttachment(req, res, next, false);
};

module.exports.downloadAttachment = function(req, res, next) {
  return processAttachment(req, res, next, true);
};

module.exports.search = function(req, res, next) {
  var parts, query, sendResults, tag;
  sendResults = function(err, files) {
    if (err) {
      return next(err);
    } else {
      return res.send(files);
    }
  };
  query = req.body.id;
  query = query.trim();
  if (query.indexOf('tag:') !== -1) {
    parts = query.split();
    parts = parts.filter(function(tag) {
      return tag.indexOf('tag:' !== -1);
    });
    tag = parts[0].split('tag:')[1];
    return File.request('byTag', {
      key: tag
    }, sendResults);
  } else {
    return File.search("*" + query + "*", sendResults);
  }
};
