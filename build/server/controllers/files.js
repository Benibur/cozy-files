// Generated by CoffeeScript 1.7.1
var File, Folder, async, fs, log, moment, pathHelpers, processAttachement, sharing;

fs = require('fs');

async = require('async');

moment = require('moment');

File = require('../models/file');

Folder = require('../models/folder');

sharing = require('../helpers/sharing');

pathHelpers = require('../helpers/path');

log = require('printit')({
  prefix: 'files'
});

processAttachement = function(req, res, download) {
  var file, id, stream;
  id = req.params.id;
  file = req.file;
  res.setHeader('Content-Disposition', (download ? "attachment; filename=" + file.name : "inline"));
  stream = file.getBinary("file", (function(_this) {
    return function(err, resp, body) {
      if (err) {
        return next(err);
      }
    };
  })(this));
  return stream.pipe(res);
};

module.exports.fetch = function(req, res, next, id) {
  return File.request('all', {
    key: id
  }, function(err, file) {
    if (err || !file || file.length === 0) {
      if (err) {
        return next(new Error("File not found"));
      } else {
        return res.send({
          error: true,
          msg: 'File not found'
        }, 404);
      }
    } else {
      req.file = file[0];
      return next();
    }
  });
};

module.exports.all = function(req, res) {
  return File.all(function(err, files) {
    if (err) {
      return next(err);
    } else {
      return res.send(files);
    }
  });
};

module.exports.create = function(req, res, next) {
  if (!req.body.name || req.body.name === "") {
    return next(new Error("Invalid arguments"));
  } else {
    return File.all((function(_this) {
      return function(err, files) {
        var available, data, file, now;
        available = pathHelpers.checkIfPathAvailable(req.body, files);
        if (!available) {
          return res.send({
            error: true,
            msg: "This file already exists"
          }, 400);
        } else {
          file = req.files["file"];
          now = moment().toISOString();
          data = {};
          data.name = req.body.name;
          data.path = req.body.path;
          data.creationDate = now;
          data.lastModification = now;
          data.mime = file.type;
          data.size = file.size;
          switch (file.type.split('/')[0]) {
            case 'image':
              data["class"] = "image";
              break;
            case 'application':
              data["class"] = "document";
              break;
            case 'text':
              data["class"] = "document";
              break;
            case 'audio':
              data["class"] = "music";
              break;
            case 'video':
              data["class"] = "video";
              break;
            default:
              data["class"] = "file";
          }
          return Folder.all(function(err, folders) {
            var fullPath, parent, parents;
            if (err) {
              return callback(err);
            }
            fullPath = data.path;
            parents = folders.filter(function(tested) {
              return fullPath === tested.getFullPath();
            });
            if (parents.length) {
              parent = parents[0];
              data.tags = parent.tags;
            } else {
              data.tags = [];
            }
            return File.createNewFile(data, file, function(err, newfile) {
              var who;
              who = req.guestEmail || 'owner';
              return sharing.notifyChanges(who, newfile, function(err) {
                if (err) {
                  console.log(err);
                }
                return res.send(newfile, 200);
              });
            });
          });
        }
      };
    })(this));
  }
};

module.exports.find = function(req, res) {
  return res.send(req.file);
};

module.exports.modify = function(req, res) {
  var body, file, isPublic, newName, newPath, tags, _ref, _ref1;
  log.info("File modification of " + req.file.name + "...");
  file = req.file;
  body = req.body;
  if (body.tags && (Array.isArray(body.tags)) && ((_ref = file.tags) != null ? _ref.toString() : void 0) !== ((_ref1 = body.tags) != null ? _ref1.toString() : void 0)) {
    tags = body.tags;
    tags = tags.filter(function(tag) {
      return typeof tag === 'string';
    });
    return file.updateAttributes({
      tags: tags
    }, (function(_this) {
      return function(err) {
        if (err) {
          return next(new Error("Cannot change tags: " + err));
        } else {
          log.info("Tags changed for " + file.name + ": " + tags);
          return res.send({
            success: 'Tags successfully changed'
          }, 200);
        }
      };
    })(this));
  } else if (!body.name || body.name === "") {
    log.info("No arguments, no modification performed for " + req.file.name);
    return next(new Error("Invalid arguments, name should be specified."));
  } else {
    newName = body.name;
    isPublic = body["public"];
    newPath = "" + file.path + "/" + newName;
    return File.all((function(_this) {
      return function(err, files) {
        var available, data, modificationSuccess;
        modificationSuccess = function(err) {
          if (err) {
            return next(new Error("Error indexing: " + err));
          } else {
            log.info("File name changed from " + file.name + " to " + newName);
            return res.send({
              success: 'File successfully modified'
            });
          }
        };
        available = pathHelpers.checkIfPathAvailable(file, files, file.id);
        if (!available) {
          log.info("No modification: Name " + newName + " already exists.");
          return res.send({
            error: true,
            msg: "The name is already in use."
          }, 400);
        } else {
          data = {
            name: newName,
            "public": isPublic
          };
          if (body.clearance) {
            data.clearance = body.clearance;
          }
          return file.updateAttributes(data, function(err) {
            if (err) {
              return next(new Error('Cannot modify file'));
            } else {
              return file.index(["name"], modificationSuccess);
            }
          });
        }
      };
    })(this));
  }
};

module.exports.destroy = function(req, res) {
  var file;
  file = req.file;
  return file.removeBinary("file", (function(_this) {
    return function(err, resp, body) {
      return file.destroy(function(err) {
        if (err) {
          console.log(err);
          return res.send({
            error: 'Cannot delete file'
          }, 500);
        } else {
          return res.send({
            success: 'File successfully deleted'
          }, 200);
        }
      });
    };
  })(this));
};

module.exports.getAttachment = function(req, res) {
  return processAttachement(req, res, false);
};

module.exports.downloadAttachment = function(req, res) {
  return processAttachement(req, res, true);
};

module.exports.publicDownloadAttachment = function(req, res) {
  return sharing.checkClearance(req.file, req, function(authorized) {
    if (!authorized) {
      return res.send(404);
    } else {
      return processAttachement(req, res, true);
    }
  });
};

module.exports.publicCreate = function(req, res, next) {
  var file;
  file = new File(req.body);
  return sharing.checkClearance(file, req, 'w', function(authorized, rule) {
    if (!rule) {
      return res.send(401);
    } else {
      req.guestEmail = rule.email;
      req.guestId = rule.contactid;
      return module.exports.create(req, res, next);
    }
  });
};

module.exports.search = function(req, res) {
  var parts, query, sendResults, tag;
  sendResults = function(err, files) {
    if (err) {
      return next(err);
    } else {
      return res.send(files);
    }
  };
  query = req.body.id;
  query = query.trim();
  if (query.indexOf('tag:') !== -1) {
    parts = query.split();
    parts = parts.filter(function(tag) {
      return tag.indexOf('tag:' !== -1);
    });
    tag = parts[0].split('tag:')[1];
    return File.request('byTag', {
      key: tag
    }, sendResults);
  } else {
    return File.search("*" + query + "*", sendResults);
  }
};
