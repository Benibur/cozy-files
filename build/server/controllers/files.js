// Generated by CoffeeScript 1.7.1
var File, Folder, async, fs, processAttachement, sharing;

File = require('../models/file');

Folder = require('../models/folder');

fs = require('fs');

async = require('async');

sharing = require('../helpers/sharing');

processAttachement = function(req, res, download) {
  var file, id, stream;
  id = req.params.id;
  file = req.file;
  res.setHeader('Content-Disposition', (download ? "attachment; filename=" + file.name : "inline"));
  stream = file.getBinary("file", (function(_this) {
    return function(err, resp, body) {
      if (err) {
        return next(err);
      }
    };
  })(this));
  return stream.pipe(res);
};

module.exports.fetch = function(req, res, next, id) {
  return File.request('all', {
    key: id
  }, function(err, file) {
    if (err || !file || file.length === 0) {
      if (err) {
        return next(new Error("File not found"));
      } else {
        return res.send({
          error: true,
          msg: 'File not found'
        }, 404);
      }
    } else {
      req.file = file[0];
      return next();
    }
  });
};

module.exports.all = function(req, res) {
  return File.all(function(err, files) {
    if (err) {
      return next(err);
    } else {
      return res.send(files);
    }
  });
};

module.exports.create = function(req, res, next) {
  if (!req.body.name || req.body.name === "") {
    return res.send({
      error: true,
      msg: "Invalid arguments"
    }, 500);
  } else {
    return File.all((function(_this) {
      return function(err, files) {
        var hasntTheSamePath;
        hasntTheSamePath = function(file, cb) {
          return cb((req.body.path + '/' + req.body.name) !== (file.path + '/' + file.name));
        };
        return async.every(files, hasntTheSamePath, function(available) {
          var data, file;
          if (!available) {
            return res.send({
              error: true,
              msg: "This file already exists"
            }, 400);
          } else {
            file = req.files["file"];
            data = {};
            data.name = req.body.name;
            data.path = req.body.path;
            data.lastModification = req.body.lastModification;
            data.mime = file.type;
            data.size = file.size;
            switch (file.type.split('/')[0]) {
              case 'image':
                data["class"] = "image";
                break;
              case 'application':
                data["class"] = "document";
                break;
              case 'text':
                data["class"] = "document";
                break;
              case 'audio':
                data["class"] = "music";
                break;
              case 'video':
                data["class"] = "video";
                break;
              default:
                data["class"] = "file";
            }
            return Folder.all((function(_this) {
              return function(err, folders) {
                var fullPath, parent, parents;
                if (err) {
                  return callback(err);
                }
                fullPath = data.path;
                parents = folders.filter(function(tested) {
                  return fullPath === tested.getFullPath();
                });
                if (parents.length) {
                  parent = parents[0];
                  data.tags = parent.tags;
                } else {
                  data.tags = [];
                }
                return File.create(data, function(err, newfile) {
                  if (err) {
                    return next(new Error("Server error while creating file; " + err));
                  }
                  return newfile.attachBinary(file.path, {
                    "name": "file"
                  }, function(err) {
                    if (err) {
                      return next(new Error("Error attaching binary: " + err));
                    }
                    return newfile.index(["name"], function(err) {
                      if (err) {
                        return next(new Error("Error indexing: " + err));
                      }
                      return fs.unlink(file.path, function(err) {
                        var who;
                        if (err) {
                          return next(new Error("Error removing uploaded file: " + err));
                        }
                        who = req.guestEmail || 'owner';
                        return sharing.notifyChanges(who, newfile, function(err) {
                          if (err) {
                            console.log(err);
                          }
                          return res.send(newfile, 200);
                        });
                      });
                    });
                  });
                });
              };
            })(this));
          }
        });
      };
    })(this));
  }
};

module.exports.find = function(req, res) {
  return res.send(req.file);
};

module.exports.modify = function(req, res) {
  var file, fileToModify, hasntTheSamePathOrIsTheSame, isPublic, newName, newPath, tags, validRequest;
  validRequest = false;
  if (req.body.name && req.body.name.trim() !== "") {
    validRequest = true;
    fileToModify = req.file;
    newName = req.body.name;
    isPublic = req.body["public"];
    newPath = fileToModify.path + '/' + newName;
    hasntTheSamePathOrIsTheSame = function(file, cb) {
      if (fileToModify.id === file.id) {
        return cb(true);
      } else {
        return cb(newPath !== (file.path + '/' + file.name));
      }
    };
    File.all((function(_this) {
      return function(err, files) {
        return async.every(files, hasntTheSamePathOrIsTheSame, function(available) {
          var data;
          if (!available) {
            return res.send({
              error: true,
              msg: "The name already in use"
            }, 400);
          } else {
            data = {
              name: newName,
              "public": isPublic
            };
            if (req.body.clearance) {
              data.clearance = req.body.clearance;
            }
            return fileToModify.updateAttributes(data, (function(_this) {
              return function(err) {
                if (err) {
                  console.log(err);
                  return res.send({
                    error: 'Cannot modify file'
                  }, 500);
                } else {
                  return fileToModify.index(["name"], function(err) {
                    if (err) {
                      return res.send({
                        error: true,
                        msg: "Error indexing: " + err
                      }, 500);
                    } else {
                      return res.send({
                        success: 'File successfully modified'
                      }, 200);
                    }
                  });
                }
              };
            })(this));
          }
        });
      };
    })(this));
  }
  if (req.body.tags && Array.isArray(req.body.tags)) {
    validRequest = true;
    file = req.file;
    tags = req.body.tags;
    tags = tags.filter(function(e) {
      return typeof e === 'string';
    });
    file.updateAttributes({
      tags: tags
    }, (function(_this) {
      return function(err) {
        if (err) {
          console.log(err);
          return res.send({
            error: 'Cannot change tags'
          }, 500);
        } else {
          return res.send({
            success: 'Tags successfully changed'
          }, 200);
        }
      };
    })(this));
  }
  if (!validRequest) {
    return res.send({
      error: true,
      msg: "No data specified"
    }, 400);
  }
};

module.exports.destroy = function(req, res) {
  var file;
  file = req.file;
  return file.removeBinary("file", (function(_this) {
    return function(err, resp, body) {
      return file.destroy(function(err) {
        if (err) {
          console.log(err);
          return res.send({
            error: 'Cannot delete file'
          }, 500);
        } else {
          return res.send({
            success: 'File successfully deleted'
          }, 200);
        }
      });
    };
  })(this));
};

module.exports.getAttachment = function(req, res) {
  return processAttachement(req, res, false);
};

module.exports.downloadAttachment = function(req, res) {
  return processAttachement(req, res, true);
};

module.exports.publicDownloadAttachment = function(req, res) {
  return sharing.checkClearance(req.file, req, function(authorized) {
    if (!authorized) {
      return res.send(404);
    } else {
      return processAttachement(req, res, true);
    }
  });
};

module.exports.publicCreate = function(req, res, next) {
  var toCreate;
  toCreate = new File(req.body);
  return sharing.checkClearance(toCreate, req, 'w', function(authorized, rule) {
    if (!rule) {
      return res.send(401);
    } else {
      req.guestEmail = rule.email;
      req.guestId = rule.contactid;
      return module.exports.create(req, res, next);
    }
  });
};

module.exports.search = function(req, res) {
  var parts, query, sendResults, tag;
  sendResults = function(err, files) {
    if (err) {
      return res.send({
        error: true,
        msg: err
      }, 500);
    } else {
      return res.send(files);
    }
  };
  query = req.body.id;
  query = query.trim();
  if (query.indexOf('tag:') !== -1) {
    parts = query.split();
    parts = parts.filter(function(e) {
      return e.indexOf('tag:' !== -1);
    });
    tag = parts[0].split('tag:')[1];
    return File.request('byTag', {
      key: tag
    }, sendResults);
  } else {
    return File.search("*" + query + "*", sendResults);
  }
};
